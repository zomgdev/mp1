<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>ER Diagram – Crow's Foot</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: sans-serif; }
    #toolbar {
      position: fixed;
      top: 10px;
      left: 10px;
      background: #fff;
      border: 1px solid #ccc;
      padding: 6px;
      display: flex;
      gap: 6px;
      z-index: 10;
      user-select: none;
    }
    canvas { background: #f4f4f4; display: block; }
    button { cursor: pointer; }
  </style>
</head>
<body>

<div id="toolbar">
  <button onclick="setTool('select')">Select</button>
  <button onclick="setTool('node')">Entity</button>
  <button onclick="setTool('link')">Link</button>
</div>

<canvas id="canvas"></canvas>

<script>
/* ================= SETUP ================= */
const canvas = document.getElementById('canvas')
const ctx = canvas.getContext('2d')

let bgPattern = null

function resize() {
  canvas.width = innerWidth
  canvas.height = innerHeight
  bgPattern = null
}
addEventListener('resize', resize)
resize()

/* ================= STATE ================= */
const state = {
  nodes: [],
  links: [],
  tool: 'select',
  selected: null,
  dragging: false,
  dragOffset: { x: 0, y: 0 },
  linkDraft: null
}

function setTool(tool) {
  state.tool = tool
  if (tool !== 'link') state.linkDraft = null
}

/* ================= BACKGROUND DOT GRID ================= */
const CM_PX = 37.8
const GRID_SPACING = Math.round(CM_PX)
const DOT_RADIUS = 1

function makeDotPattern() {
  const p = document.createElement('canvas')
  p.width = GRID_SPACING
  p.height = GRID_SPACING
  const pctx = p.getContext('2d')

  pctx.clearRect(0, 0, p.width, p.height)
  pctx.beginPath()
  pctx.arc(GRID_SPACING / 2, GRID_SPACING / 2, DOT_RADIUS, 0, Math.PI * 2)
  pctx.fillStyle = 'rgba(0,0,0,0.18)'
  pctx.fill()

  return ctx.createPattern(p, 'repeat')
}

function drawBackgroundDots() {
  if (!bgPattern) bgPattern = makeDotPattern()
  ctx.save()
  ctx.setTransform(1, 0, 0, 1, 0, 0)
  ctx.fillStyle = bgPattern
  ctx.fillRect(0, 0, canvas.width, canvas.height)
  ctx.restore()
}

/* ================= HELPERS ================= */
function hitNode(x, y) {
  for (let i = state.nodes.length - 1; i >= 0; i--) {
    const n = state.nodes[i]
    if (x >= n.x && x <= n.x + n.width &&
        y >= n.y && y <= n.y + n.height) return n
  }
  return null
}

function center(n) {
  return { x: n.x + n.width / 2, y: n.y + n.height / 2 }
}

function calcNodeHeight(n) {
  return 24 + 16 + n.fields.length * 14
}

/* ================= GEOMETRY ================= */
function intersection(rect, target) {
  const cx = rect.x + rect.width / 2
  const cy = rect.y + rect.height / 2
  const dx = target.x - cx
  const dy = target.y - cy
  const adx = Math.abs(dx) || 0.00001
  const ady = Math.abs(dy) || 0.00001
  const scale = Math.min(rect.width / 2 / adx, rect.height / 2 / ady)
  return { x: cx + dx * scale, y: cy + dy * scale }
}

/* ================= CARDINALITY ================= */
function drawCrowFoot(x, y, angle) {
  const s = 10, sp = Math.PI / 6
  for (let i of [-1, 0, 1]) {
    ctx.beginPath()
    ctx.moveTo(x, y)
    ctx.lineTo(
      x + Math.cos(angle + sp * i) * s,
      y + Math.sin(angle + sp * i) * s
    )
    ctx.stroke()
  }
}

function drawOne(x, y, angle) {
  const s = 8, a = angle + Math.PI / 2
  ctx.beginPath()
  ctx.moveTo(x + Math.cos(a) * s, y + Math.sin(a) * s)
  ctx.lineTo(x - Math.cos(a) * s, y - Math.sin(a) * s)
  ctx.stroke()
}

function drawZero(x, y) {
  ctx.beginPath()
  ctx.arc(x, y, 4, 0, Math.PI * 2)
  ctx.stroke()
}

function drawCardinality(type, x, y, angle) {
  if (type === 'one') drawOne(x, y, angle)
  if (type === 'many') drawCrowFoot(x, y, angle)
  if (type === 'zero-one') {
    drawZero(x, y)
    drawOne(x, y, angle)
  }
}

/* ================= DRAW ================= */
function drawNode(n) {
  n.height = calcNodeHeight(n)

  // ---- НЕПРОЗРАЧНЫЙ ФОН ENTITY ----
  ctx.fillStyle = '#ffffff'
  ctx.fillRect(n.x, n.y, n.width, n.height)

  ctx.strokeStyle = '#222'
  ctx.strokeRect(n.x, n.y, n.width, n.height)

  // header
  ctx.fillStyle = '#eeeeee'
  ctx.fillRect(n.x, n.y, n.width, 24)
  ctx.strokeRect(n.x, n.y, n.width, 24)

  ctx.fillStyle = '#000'
  ctx.font = 'bold 12px sans-serif'
  ctx.fillText(n.title, n.x + 6, n.y + 16)

  ctx.font = '12px monospace'
  n.fields.forEach((f, i) => {
    ctx.fillText(
      `${f.name}: ${f.type}${f.meta ? ' [' + f.meta + ']' : ''}`,
      n.x + 6,
      n.y + 40 + i * 14
    )
  })
}

function drawLink(l) {
  const a = state.nodes.find(n => n.id === l.from)
  const b = state.nodes.find(n => n.id === l.to)
  if (!a || !b) return

  const p1 = intersection(a, center(b))
  const p2 = intersection(b, center(a))

  ctx.beginPath()
  ctx.moveTo(p1.x, p1.y)
  ctx.lineTo(p2.x, p2.y)
  ctx.stroke()

  const ang = Math.atan2(p2.y - p1.y, p2.x - p1.x)
  drawCardinality(l.fromCardinality, p1.x, p1.y, ang)
  drawCardinality(l.toCardinality, p2.x, p2.y, ang + Math.PI)
}

/* ================= EVENTS ================= */
canvas.onmousedown = e => {
  const x = e.offsetX
  const y = e.offsetY
  const hit = hitNode(x, y)

  if (state.tool === 'node') {
    state.nodes.push({
      id: crypto.randomUUID(),
      x, y,
      width: 180,
      title: 'Entity',
      fields: [{ name: 'id', type: 'int', meta: 'PK' }]
    })
    return
  }

  if (state.tool === 'link') {
    if (hit) {
      if (!state.linkDraft) {
        state.linkDraft = { from: hit, toPoint: { x, y } }
      } else if (state.linkDraft.from !== hit) {
        state.links.push({
          id: crypto.randomUUID(),
          from: state.linkDraft.from.id,
          to: hit.id,
          fromCardinality: 'one',
          toCardinality: 'many'
        })
        state.linkDraft = null
      }
      return
    }
    state.linkDraft = null
    return
  }

  if (state.tool === 'select' && hit) {
    state.selected = hit
    state.dragging = true
    state.dragOffset = { x: x - hit.x, y: y - hit.y }
  }
}

canvas.onmousemove = e => {
  const x = e.offsetX
  const y = e.offsetY

  if (state.linkDraft) {
    state.linkDraft.toPoint = { x, y }
  }

  if (state.dragging && state.selected) {
    state.selected.x = x - state.dragOffset.x
    state.selected.y = y - state.dragOffset.y
  }
}

canvas.onmouseup = () => {
  state.dragging = false
  state.selected = null
}

canvas.ondblclick = e => {
  const x = e.offsetX
  const y = e.offsetY
  const node = hitNode(x, y)
  if (!node) return

  if (y <= node.y + 24) {
    const t = prompt('Entity name:', node.title)
    if (t) node.title = t.trim()
    return
  }

  const idx = Math.floor((y - (node.y + 40)) / 14)
  if (idx >= 0 && idx < node.fields.length) {
    const f = node.fields[idx]
    const v = prompt(
      'Field (name:type [meta]):',
      `${f.name}:${f.type}${f.meta ? ' [' + f.meta + ']' : ''}`
    )
    if (!v) return
    const m = v.match(/^(\w+):(\w+)(?:\s*\[(.+)\])?$/)
    if (!m) return
    f.name = m[1]
    f.type = m[2]
    f.meta = m[3] || null
  }
}

canvas.oncontextmenu = e => {
  e.preventDefault()
  state.linkDraft = null
}

addEventListener('keydown', e => {
  if (e.key === 'Escape') state.linkDraft = null
})

/* ================= LOOP ================= */
function loop() {
  ctx.clearRect(0, 0, canvas.width, canvas.height)
  drawBackgroundDots()

  state.links.forEach(drawLink)
  state.nodes.forEach(drawNode)

  if (state.linkDraft && state.linkDraft.toPoint) {
    const p1 = intersection(state.linkDraft.from, state.linkDraft.toPoint)
    const p2 = state.linkDraft.toPoint
    ctx.setLineDash([6, 6])
    ctx.beginPath()
    ctx.moveTo(p1.x, p1.y)
    ctx.lineTo(p2.x, p2.y)
    ctx.stroke()
    ctx.setLineDash([])
  }

  requestAnimationFrame(loop)
}
loop()
</script>

</body>
</html>
