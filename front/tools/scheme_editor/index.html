<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>ER Diagram – Crow's Foot</title>
  <style>
    :root{
      --panel-bg:#fff;
      --panel-border:#d7d7d7;
      --panel-shadow: 0 10px 24px rgba(0,0,0,.10);
      --icon:#2b2b2b;
      --accent:#1e88e5;
      --hover:#f2f5f8;
    }

    body { margin: 0; overflow: hidden; font-family: sans-serif; }
    canvas { background: #f4f4f4; display: block; }

    /* ================= TOOLBAR (VERTICAL) ================= */
    #toolpanel {
      position: fixed;
      top: 12px;
      left: 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      padding: 10px;
      background: var(--panel-bg);
      border: 1px solid var(--panel-border);
      border-radius: 12px;
      box-shadow: var(--panel-shadow);
      z-index: 10;
      user-select: none;
    }

    .toolbtn {
      width: 44px;
      height: 44px;
      border: 1px solid transparent;
      border-radius: 10px;
      background: transparent;
      display: grid;
      place-items: center;
      cursor: pointer;
      position: relative;
      outline: none;
    }

    .toolbtn:hover {
      background: var(--hover);
      border-color: #e8e8e8;
    }

    .toolbtn:active { transform: translateY(1px); }

    .toolbtn.active {
      background: rgba(30,136,229,0.12);
      border-color: rgba(30,136,229,0.35);
    }

    .toolbtn svg {
      width: 22px;
      height: 22px;
      stroke: var(--icon);
      fill: none;
      stroke-width: 2;
      stroke-linecap: round;
      stroke-linejoin: round;
    }

    .toolbtn.active svg { stroke: var(--accent); }

    /* Tooltip */
    .toolbtn[data-tip]::after {
      content: attr(data-tip);
      position: absolute;
      left: 54px;
      top: 50%;
      transform: translateY(-50%);
      background: rgba(20,20,20,0.92);
      color: #fff;
      font-size: 12px;
      padding: 6px 8px;
      border-radius: 8px;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity .12s ease;
    }
    .toolbtn[data-tip]::before {
      content: "";
      position: absolute;
      left: 48px;
      top: 50%;
      transform: translateY(-50%);
      border: 6px solid transparent;
      border-right-color: rgba(20,20,20,0.92);
      opacity: 0;
      pointer-events: none;
      transition: opacity .12s ease;
    }
    .toolbtn:hover::after,
    .toolbtn:hover::before { opacity: 1; }

    /* Маленький статус (для проверки) */
    #toolstatus{
      position: fixed;
      top: 14px;
      left: 84px;
      background: rgba(255,255,255,0.92);
      border: 1px solid #ddd;
      border-radius: 10px;
      padding: 8px 10px;
      font-size: 12px;
      z-index: 11;
      box-shadow: 0 6px 18px rgba(0,0,0,0.08);
      user-select: none;
    }

    /* Панель редактора сущности */
    #entity-editor {
      position: fixed;
      top: 70px;
      left: 84px;
      width: 360px;
      background: #fff;
      border: 1px solid #ccc;
      padding: 10px;
      z-index: 30;
      display: none;
      box-shadow: 0 6px 18px rgba(0,0,0,0.12);
      border-radius: 12px;
    }
    #entity-editor h3 { margin: 0 0 8px 0; font-size: 14px; }
    #entity-editor label { display: block; font-size: 12px; margin: 8px 0 4px; }
    #entity-title-input { width: 100%; box-sizing: border-box; padding: 6px; font-size: 12px; }
    #entity-fields-text {
      width: 100%;
      height: 160px;
      box-sizing: border-box;
      padding: 6px;
      font-size: 12px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      resize: vertical;
    }
    #entity-editor .row { display: flex; gap: 8px; margin-top: 10px; }
    #entity-editor .row button { flex: 1; padding: 8px; font-size: 12px; cursor: pointer; }
    #entity-editor .hint { margin-top: 8px; font-size: 11px; color: #555; line-height: 1.3; }
    #entity-editor .error { margin-top: 8px; font-size: 11px; color: #b00020; display: none; white-space: pre-wrap; }
  </style>
</head>
<body>

<div id="toolpanel" aria-label="Tools">
  <button type="button" class="toolbtn active" data-tool="select" data-tip="Выбор / Перемещение (Select)">
    <svg viewBox="0 0 24 24" aria-hidden="true">
      <path d="M4 3l7.5 17 2.2-6 6 0.6L4 3z"></path>
    </svg>
  </button>

  <button type="button" class="toolbtn" data-tool="node" data-tip="Добавить сущность (Entity)">
    <svg viewBox="0 0 24 24" aria-hidden="true">
      <rect x="5" y="6" width="14" height="12" rx="2"></rect>
      <path d="M5 10h14"></path>
      <path d="M8 14h8"></path>
    </svg>
  </button>

  <button type="button" class="toolbtn" data-tool="link" data-tip="Связь (Link)">
    <svg viewBox="0 0 24 24" aria-hidden="true">
      <path d="M7 12a4 4 0 0 1 4-4h2"></path>
      <path d="M17 12a4 4 0 0 1-4 4h-2"></path>
      <path d="M10 12h4"></path>
      <path d="M14.5 8.5l2-2a3 3 0 0 1 4.2 4.2l-2 2"></path>
      <path d="M9.5 15.5l-2 2a3 3 0 0 1-4.2-4.2l2-2"></path>
    </svg>
  </button>
</div>

<div id="toolstatus">Tool: <b id="toolstatusValue">select</b></div>

<div id="entity-editor">
  <h3>Entity editor</h3>

  <label for="entity-title-input">Заголовок</label>
  <input id="entity-title-input" type="text" />

  <label for="entity-fields-text">Поля (по одному в строке)</label>
  <textarea id="entity-fields-text" placeholder="id:int [PK]
user_id:int [FK]
email:varchar"></textarea>

  <div class="row">
    <button type="button" onclick="applyEntityEditor()">Применить</button>
    <button type="button" onclick="closeEntityEditor()">Отмена</button>
  </div>

  <div class="hint">
    Формат строк: <b>name:type [meta]</b><br/>
    Примеры meta: PK, FK, UQ, NN, IDX и т.п.<br/>
    Пустые строки игнорируются.
  </div>

  <div id="entity-editor-error" class="error"></div>
</div>

<canvas id="canvas"></canvas>

<script>
/* ================= SETUP ================= */
const canvas = document.getElementById('canvas')
const ctx = canvas.getContext('2d')
let bgPattern = null

/* ================= STATE ================= */
const state = {
  nodes: [],
  links: [],
  tool: 'select',
  selected: null,
  selectedLinkId: null,
  dragging: false,
  dragOffset: { x: 0, y: 0 },
  linkDraft: null,
  editingNode: null,
  refsCache: new Map(),

  linkPaths: new Map(),
  layoutVersion: 0,
  lastRoutedVersion: -1
}

/* Функция: увеличивает версию лэйаута (когда меняется геометрия/размеры) */
function bumpLayoutVersion() {
  state.layoutVersion++
}

/* Функция: подгоняет размеры canvas под окно браузера */
function resize() {
  canvas.width = innerWidth
  canvas.height = innerHeight
  bgPattern = null
  bumpLayoutVersion()
}
addEventListener('resize', resize)
resize()

/* ================= TOOL PANEL ================= */
const toolStatusEl = document.getElementById('toolstatusValue')

/* Функция: применяет active-класс для кнопок инструмента */
function setActiveToolButton(tool) {
  document.querySelectorAll('.toolbtn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.tool === tool)
  })
}

/* Функция: переключает инструмент (select/node/link) */
function setTool(tool) {
  state.tool = tool
  if (tool !== 'link') state.linkDraft = null
  setActiveToolButton(tool)
  toolStatusEl.textContent = tool
}

/* Функция: инициализирует клики по кнопкам панели */
function initToolPanel() {
  document.querySelectorAll('.toolbtn').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.preventDefault()
      e.stopPropagation()
      setTool(btn.dataset.tool)
    })
  })
}
initToolPanel()
setTool('select')

/* ================= BACKGROUND DOT GRID ================= */
const CM_PX = 37.8
const GRID_SPACING = Math.round(CM_PX)
const DOT_RADIUS = 1

/* Функция: создаёт паттерн из точек для заливки фона */
function makeDotPattern() {
  const p = document.createElement('canvas')
  p.width = GRID_SPACING
  p.height = GRID_SPACING
  const pctx = p.getContext('2d')

  pctx.clearRect(0, 0, p.width, p.height)
  pctx.beginPath()
  pctx.arc(GRID_SPACING / 2, GRID_SPACING / 2, DOT_RADIUS, 0, Math.PI * 2)
  pctx.fillStyle = 'rgba(0,0,0,0.18)'
  pctx.fill()

  return ctx.createPattern(p, 'repeat')
}

/* Функция: рисует фон рабочей области точками */
function drawBackgroundDots() {
  if (!bgPattern) bgPattern = makeDotPattern()
  ctx.save()
  ctx.setTransform(1, 0, 0, 1, 0, 0)
  ctx.fillStyle = bgPattern
  ctx.fillRect(0, 0, canvas.width, canvas.height)
  ctx.restore()
}

/* ================= HELPERS ================= */
/* Функция: находит entity под курсором */
function hitNode(x, y) {
  for (let i = state.nodes.length - 1; i >= 0; i--) {
    const n = state.nodes[i]
    if (x >= n.x && x <= n.x + n.width &&
        y >= n.y && y <= n.y + n.height) return n
  }
  return null
}

/* Функция: возвращает центр прямоугольника entity */
function center(n) {
  return { x: n.x + n.width / 2, y: n.y + n.height / 2 }
}

/* Функция: вычисляет высоту entity по количеству строк (поля + refs) */
function calcNodeHeight(n) {
  const line = 14
  const header = 24
  const padding = 16

  const fieldsLines = n.fields.length
  const refs = state.refsCache.get(n.id) || []
  const refsHeaderLines = refs.length > 0 ? 1 : 0
  const refsLines = refs.length

  const totalLines = fieldsLines + refsHeaderLines + refsLines
  return header + padding + totalLines * line
}

/* ================= GEOMETRY ================= */
/* Функция: вычисляет точку пересечения линии с границей прямоугольника entity */
function intersection(rect, target) {
  const cx = rect.x + rect.width / 2
  const cy = rect.y + rect.height / 2
  const dx = target.x - cx
  const dy = target.y - cy
  const adx = Math.abs(dx) || 0.00001
  const ady = Math.abs(dy) || 0.00001
  const scale = Math.min(rect.width / 2 / adx, rect.height / 2 / ady)
  return { x: cx + dx * scale, y: cy + dy * scale }
}

/* Функция: расстояние от точки до отрезка */
function distPointToSegment(px, py, x1, y1, x2, y2) {
  const vx = x2 - x1
  const vy = y2 - y1
  const wx = px - x1
  const wy = py - y1

  const c1 = wx * vx + wy * vy
  if (c1 <= 0) return Math.hypot(px - x1, py - y1)

  const c2 = vx * vx + vy * vy
  if (c2 <= c1) return Math.hypot(px - x2, py - y2)

  const t = c1 / c2
  const projx = x1 + t * vx
  const projy = y1 + t * vy
  return Math.hypot(px - projx, py - projy)
}

/* ================= CARDINALITY ================= */
function drawCrowFoot(x, y, angle) {
  const s = 10, sp = Math.PI / 6
  for (let i of [-1, 0, 1]) {
    ctx.beginPath()
    ctx.moveTo(x, y)
    ctx.lineTo(
      x + Math.cos(angle + sp * i) * s,
      y + Math.sin(angle + sp * i) * s
    )
    ctx.stroke()
  }
}
function drawOne(x, y, angle) {
  const s = 8, a = angle + Math.PI / 2
  ctx.beginPath()
  ctx.moveTo(x + Math.cos(a) * s, y + Math.sin(a) * s)
  ctx.lineTo(x - Math.cos(a) * s, y - Math.sin(a) * s)
  ctx.stroke()
}
function drawZero(x, y) {
  ctx.beginPath()
  ctx.arc(x, y, 4, 0, Math.PI * 2)
  ctx.stroke()
}
function drawCardinality(type, x, y, angle) {
  if (type === 'one') drawOne(x, y, angle)
  if (type === 'many') drawCrowFoot(x, y, angle)
  if (type === 'zero-one') { drawZero(x, y); drawOne(x, y, angle) }
}

/* ================= REFERENCES (TRANSITIVE) ================= */
function buildAdjacency() {
  const adj = new Map()
  for (const l of state.links) {
    if (!adj.has(l.from)) adj.set(l.from, new Set())
    adj.get(l.from).add(l.to)
  }
  return adj
}
function collectReachable(adj, startId) {
  const visited = new Set([startId])
  const stack = [startId]
  while (stack.length) {
    const v = stack.pop()
    const next = adj.get(v)
    if (!next) continue
    for (const u of next) {
      if (visited.has(u)) continue
      visited.add(u)
      stack.push(u)
    }
  }
  visited.delete(startId)
  return visited
}
function updateRefsCache() {
  const adj = buildAdjacency()
  const titleById = new Map()
  for (const n of state.nodes) titleById.set(n.id, n.title)

  const cache = new Map()
  for (const n of state.nodes) {
    const reachable = collectReachable(adj, n.id)
    const titles = []
    for (const id of reachable) {
      const t = titleById.get(id)
      if (t) titles.push(t)
    }
    titles.sort((a, b) => a.localeCompare(b, 'ru'))
    cache.set(n.id, titles)
  }
  state.refsCache = cache
}

/* ================= ROUTING (A* on GRID) ================= */
const ROUTE_CELL = 18
const ROUTE_MARGIN = 14
const ROUTE_MAX_ITERS = 50000

function toCell(p) { return { cx: Math.floor(p.x / ROUTE_CELL), cy: Math.floor(p.y / ROUTE_CELL) } }
function cellCenter(cx, cy) { return { x: cx * ROUTE_CELL + ROUTE_CELL / 2, y: cy * ROUTE_CELL + ROUTE_CELL / 2 } }
function cellKey(cx, cy) { return `${cx},${cy}` }

function buildBlockedCells(startPt, endPt) {
  const blocked = new Set()
  const wCells = Math.ceil(canvas.width / ROUTE_CELL)
  const hCells = Math.ceil(canvas.height / ROUTE_CELL)

  for (const n of state.nodes) {
    const rect = {
      x: n.x - ROUTE_MARGIN,
      y: n.y - ROUTE_MARGIN,
      width: n.width + ROUTE_MARGIN * 2,
      height: n.height + ROUTE_MARGIN * 2
    }

    const minCx = Math.max(0, Math.floor(rect.x / ROUTE_CELL))
    const maxCx = Math.min(wCells - 1, Math.floor((rect.x + rect.width) / ROUTE_CELL))
    const minCy = Math.max(0, Math.floor(rect.y / ROUTE_CELL))
    const maxCy = Math.min(hCells - 1, Math.floor((rect.y + rect.height) / ROUTE_CELL))

    for (let cy = minCy; cy <= maxCy; cy++) {
      for (let cx = minCx; cx <= maxCx; cx++) {
        const c = cellCenter(cx, cy)
        if (c.x >= rect.x && c.x <= rect.x + rect.width && c.y >= rect.y && c.y <= rect.y + rect.height) {
          blocked.add(cellKey(cx, cy))
        }
      }
    }
  }

  const s = toCell(startPt)
  const t = toCell(endPt)
  blocked.delete(cellKey(s.cx, s.cy))
  blocked.delete(cellKey(t.cx, t.cy))
  return blocked
}

function astar(startPt, endPt) {
  const wCells = Math.ceil(canvas.width / ROUTE_CELL)
  const hCells = Math.ceil(canvas.height / ROUTE_CELL)

  const start = toCell(startPt)
  const goal = toCell(endPt)
  const blocked = buildBlockedCells(startPt, endPt)

  const open = new Map()
  const cameFrom = new Map()
  const gScore = new Map()

  const h = (cx, cy) => Math.abs(cx - goal.cx) + Math.abs(cy - goal.cy)

  const startK = cellKey(start.cx, start.cy)
  gScore.set(startK, 0)
  open.set(startK, { cx: start.cx, cy: start.cy, f: h(start.cx, start.cy) })

  let iters = 0
  while (open.size && iters++ < ROUTE_MAX_ITERS) {
    let currentK = null
    let current = null
    for (const [k, v] of open.entries()) {
      if (!current || v.f < current.f) { current = v; currentK = k }
    }
    if (!currentK) break
    open.delete(currentK)

    if (current.cx === goal.cx && current.cy === goal.cy) {
      const path = []
      let k = currentK
      path.push({ cx: current.cx, cy: current.cy })
      while (cameFrom.has(k)) {
        k = cameFrom.get(k)
        const [cx, cy] = k.split(',').map(Number)
        path.push({ cx, cy })
      }
      path.reverse()
      return path
    }

    const neighbors = [
      { cx: current.cx + 1, cy: current.cy },
      { cx: current.cx - 1, cy: current.cy },
      { cx: current.cx, cy: current.cy + 1 },
      { cx: current.cx, cy: current.cy - 1 }
    ]

    for (const nb of neighbors) {
      if (nb.cx < 0 || nb.cy < 0 || nb.cx >= wCells || nb.cy >= hCells) continue
      const nbK = cellKey(nb.cx, nb.cy)
      if (blocked.has(nbK)) continue

      const tentativeG = (gScore.get(currentK) ?? Infinity) + 1
      const oldG = gScore.get(nbK)
      if (oldG === undefined || tentativeG < oldG) {
        cameFrom.set(nbK, currentK)
        gScore.set(nbK, tentativeG)
        open.set(nbK, { cx: nb.cx, cy: nb.cy, f: tentativeG + h(nb.cx, nb.cy) })
      }
    }
  }
  return null
}

function simplifyPolyline(points) {
  if (points.length <= 2) return points.slice()
  const out = [points[0]]
  for (let i = 1; i < points.length - 1; i++) {
    const a = out[out.length - 1]
    const b = points[i]
    const c = points[i + 1]
    const abx = Math.sign(b.x - a.x), aby = Math.sign(b.y - a.y)
    const bcx = Math.sign(c.x - b.x), bcy = Math.sign(c.y - b.y)
    if (abx === bcx && aby === bcy) continue
    out.push(b)
  }
  out.push(points[points.length - 1])
  return out
}

function routeLink(link) {
  const a = state.nodes.find(n => n.id === link.from)
  const b = state.nodes.find(n => n.id === link.to)
  if (!a || !b) return null

  const startAnchor = intersection(a, center(b))
  const endAnchor   = intersection(b, center(a))

  const cellPath = astar(startAnchor, endAnchor)
  if (!cellPath || cellPath.length < 2) {
    const pts = [startAnchor, endAnchor]
    const startDir = { x: endAnchor.x - startAnchor.x, y: endAnchor.y - startAnchor.y }
    const endDir = { x: startAnchor.x - endAnchor.x, y: startAnchor.y - endAnchor.y }
    return { points: pts, startDir, endDir }
  }

  const pts = [startAnchor]
  for (let i = 1; i < cellPath.length - 1; i++) pts.push(cellCenter(cellPath[i].cx, cellPath[i].cy))
  pts.push(endAnchor)

  const simple = simplifyPolyline(pts)
  const p0 = simple[0], p1 = simple[1] || simple[0]
  const pn = simple[simple.length - 1], pn1 = simple[simple.length - 2] || pn

  const startDir = { x: p1.x - p0.x, y: p1.y - p0.y }
  const endDir   = { x: pn1.x - pn.x, y: pn1.y - pn.y }
  return { points: simple, startDir, endDir }
}

function ensureRouted() {
  if (state.lastRoutedVersion === state.layoutVersion) return
  state.linkPaths.clear()
  for (const l of state.links) {
    const routed = routeLink(l)
    if (routed) state.linkPaths.set(l.id, routed)
  }
  state.lastRoutedVersion = state.layoutVersion
}

/* ================= HIT TEST LINK (POLYLINE) ================= */
function hitLink(x, y) {
  const TH = 7
  ensureRouted()

  for (let i = state.links.length - 1; i >= 0; i--) {
    const l = state.links[i]
    const path = state.linkPaths.get(l.id)
    if (!path || !path.points || path.points.length < 2) continue

    const pts = path.points
    for (let k = 0; k < pts.length - 1; k++) {
      const a = pts[k], b = pts[k + 1]
      if (distPointToSegment(x, y, a.x, a.y, b.x, b.y) <= TH) return l
    }
  }
  return null
}

/* ================= SMOOTH LINKS ================= */
const LINK_CORNER_RADIUS = 10

/* Функция: возвращает нормализованное направление (dx,dy) для ортогональных сегментов */
function orthoDir(a, b) {
  const dx = b.x - a.x
  const dy = b.y - a.y
  if (Math.abs(dx) >= Math.abs(dy)) return { x: Math.sign(dx) || 0, y: 0 }
  return { x: 0, y: Math.sign(dy) || 0 }
}

/* Функция: рисует ломаную с округлением углов (через arcTo) */
function strokeRoundedPolyline(points, radius) {
  if (!points || points.length < 2) return
  if (points.length === 2 || radius <= 0) {
    ctx.beginPath()
    ctx.moveTo(points[0].x, points[0].y)
    ctx.lineTo(points[1].x, points[1].y)
    ctx.stroke()
    return
  }

  ctx.beginPath()
  ctx.moveTo(points[0].x, points[0].y)

  for (let i = 1; i < points.length - 1; i++) {
    const prev = points[i - 1]
    const cur  = points[i]
    const next = points[i + 1]

    const inDir  = orthoDir(cur, prev)  // направление "внутрь" назад
    const outDir = orthoDir(cur, next)  // направление вперёд

    // длины входящего/выходящего сегмента
    const inLen  = Math.hypot(cur.x - prev.x, cur.y - prev.y)
    const outLen = Math.hypot(next.x - cur.x, next.y - cur.y)

    // радиус ограничиваем половинами сегментов, чтобы не было “перелётов”
    const r = Math.min(radius, inLen / 2, outLen / 2)

    // точки до/после угла
    const pBefore = { x: cur.x + inDir.x * r,  y: cur.y + inDir.y * r }
    const pAfter  = { x: cur.x + outDir.x * r, y: cur.y + outDir.y * r }

    ctx.lineTo(pBefore.x, pBefore.y)
    ctx.arcTo(cur.x, cur.y, pAfter.x, pAfter.y, r)
  }

  const last = points[points.length - 1]
  ctx.lineTo(last.x, last.y)
  ctx.stroke()
}

/* ================= DRAW ================= */
function drawNode(n) {
  const newH = calcNodeHeight(n)
  if ((n.height ?? 0) !== newH) {
    n.height = newH
    bumpLayoutVersion()
  }

  ctx.fillStyle = '#ffffff'
  ctx.fillRect(n.x, n.y, n.width, n.height)

  ctx.strokeStyle = '#222'
  ctx.lineWidth = 1
  ctx.strokeRect(n.x, n.y, n.width, n.height)

  ctx.fillStyle = '#eeeeee'
  ctx.fillRect(n.x, n.y, n.width, 24)
  ctx.strokeRect(n.x, n.y, n.width, 24)

  ctx.fillStyle = '#000'
  ctx.font = 'bold 12px sans-serif'
  ctx.fillText(n.title, n.x + 6, n.y + 16)

  ctx.font = '12px monospace'
  const lineH = 14
  let y = n.y + 40

  n.fields.forEach((f) => {
    ctx.fillText(`${f.name}: ${f.type}${f.meta ? ' [' + f.meta + ']' : ''}`, n.x + 6, y)
    y += lineH
  })

  const refs = state.refsCache.get(n.id) || []
  if (refs.length > 0) {
    ctx.strokeStyle = 'rgba(0,0,0,0.15)'
    ctx.beginPath()
    ctx.moveTo(n.x + 4, y + 4)
    ctx.lineTo(n.x + n.width - 4, y + 4)
    ctx.stroke()

    y += lineH

    ctx.fillStyle = '#000'
    ctx.font = 'bold 12px sans-serif'
    ctx.fillText('References:', n.x + 6, y)
    y += lineH

    ctx.font = '12px monospace'
    refs.forEach((t) => {
      ctx.fillText(`→ ${t}`, n.x + 6, y)
      y += lineH
    })
  }
}

/* Функция: рисует связь с округлением углов + кардинальности */
function drawLink(l) {
  const path = state.linkPaths.get(l.id)
  if (!path || !path.points || path.points.length < 2) return

  const selected = (state.selectedLinkId === l.id)
  ctx.strokeStyle = selected ? '#1e88e5' : '#222'
  ctx.lineWidth = selected ? 2 : 1
  ctx.setLineDash([])

  // Сглаживание: округляем углы ломаной
  ctx.lineJoin = 'round'
  ctx.lineCap = 'round'
  strokeRoundedPolyline(path.points, LINK_CORNER_RADIUS)

  const pts = path.points
  const startAngle = Math.atan2(path.startDir.y, path.startDir.x)
  const endAngle   = Math.atan2(path.endDir.y, path.endDir.x)

  drawCardinality(l.fromCardinality, pts[0].x, pts[0].y, startAngle)
  drawCardinality(l.toCardinality, pts[pts.length - 1].x, pts[pts.length - 1].y, endAngle)

  ctx.lineWidth = 1
}

/* ================= ENTITY EDITOR ================= */
const editorEl = document.getElementById('entity-editor')
const editorTitleInput = document.getElementById('entity-title-input')
const editorFieldsText = document.getElementById('entity-fields-text')
const editorErrorEl = document.getElementById('entity-editor-error')

function openEntityEditor(node) {
  state.editingNode = node
  editorTitleInput.value = node.title
  editorFieldsText.value = stringifyFields(node.fields)
  editorErrorEl.style.display = 'none'
  editorErrorEl.textContent = ''
  editorEl.style.display = 'block'
  editorTitleInput.focus()
}
function closeEntityEditor() {
  state.editingNode = null
  editorEl.style.display = 'none'
  editorErrorEl.style.display = 'none'
  editorErrorEl.textContent = ''
}
function applyEntityEditor() {
  const node = state.editingNode
  if (!node) return

  const newTitle = editorTitleInput.value.trim()
  if (newTitle) node.title = newTitle

  const parsed = parseFieldsText(editorFieldsText.value)
  if (!parsed.ok) {
    editorErrorEl.style.display = 'block'
    editorErrorEl.textContent = parsed.error
    return
  }

  node.fields = parsed.fields
  closeEntityEditor()
  bumpLayoutVersion()
}
function stringifyFields(fields) {
  return fields.map(f => `${f.name}:${f.type}${f.meta ? ' [' + f.meta + ']' : ''}`).join('\n')
}
function parseFieldsText(text) {
  const lines = text.split(/\r?\n/)
  const fields = []
  const errors = []

  for (let i = 0; i < lines.length; i++) {
    const raw = lines[i].trim()
    if (!raw) continue
    const m = raw.match(/^(\w+)\s*:\s*([A-Za-z0-9_]+)(?:\s*\[(.+)\])?$/)
    if (!m) { errors.push(`Строка ${i + 1}: неверный формат -> "${lines[i]}"`); continue }
    fields.push({ name: m[1], type: m[2], meta: m[3] ? m[3].trim() : null })
  }

  if (errors.length) return { ok: false, error: errors.join('\n') }
  if (fields.length === 0) fields.push({ name: 'id', type: 'int', meta: 'PK' })
  return { ok: true, fields }
}
function editSingleField(node, index) {
  const f = node.fields[index]
  const current = `${f.name}:${f.type}${f.meta ? ' [' + f.meta + ']' : ''}`
  const value = prompt('Поле (name:type [meta]):', current)
  if (value === null) return
  const v = value.trim()
  if (!v) return
  const m = v.match(/^(\w+)\s*:\s*([A-Za-z0-9_]+)(?:\s*\[(.+)\])?$/)
  if (!m) { alert('Неверный формат. Пример: user_id:int [FK]'); return }
  f.name = m[1]; f.type = m[2]; f.meta = m[3] ? m[3].trim() : null
  bumpLayoutVersion()
}

/* ================= EVENTS ================= */
canvas.onmousedown = e => {
  const x = e.offsetX
  const y = e.offsetY

  if (state.tool === 'select') {
    const link = hitLink(x, y)
    if (link) {
      state.selectedLinkId = link.id
      state.dragging = false
      state.selected = null
      return
    }
  }

  const hit = hitNode(x, y)

  if (state.tool === 'node') {
    state.nodes.push({
      id: crypto.randomUUID(),
      x, y,
      width: 220,
      title: 'Entity',
      fields: [{ name: 'id', type: 'int', meta: 'PK' }]
    })
    bumpLayoutVersion()
    return
  }

  if (state.tool === 'link') {
    if (hit) {
      if (!state.linkDraft) {
        state.linkDraft = { from: hit, toPoint: { x, y } }
      } else if (state.linkDraft.from !== hit) {
        state.links.push({
          id: crypto.randomUUID(),
          from: state.linkDraft.from.id,
          to: hit.id,
          fromCardinality: 'one',
          toCardinality: 'many'
        })
        state.linkDraft = null
        bumpLayoutVersion()
      }
      return
    }
    state.linkDraft = null
    return
  }

  if (state.tool === 'select') {
    if (hit) {
      state.selected = hit
      state.dragging = true
      state.dragOffset = { x: x - hit.x, y: y - hit.y }
      state.selectedLinkId = null
      return
    }
    state.selectedLinkId = null
    state.selected = null
  }
}

canvas.onmousemove = e => {
  const x = e.offsetX
  const y = e.offsetY

  if (state.linkDraft) state.linkDraft.toPoint = { x, y }

  if (state.dragging && state.selected) {
    state.selected.x = x - state.dragOffset.x
    state.selected.y = y - state.dragOffset.y
    bumpLayoutVersion()
  }
}

canvas.onmouseup = () => {
  state.dragging = false
  state.selected = null
}

canvas.ondblclick = e => {
  const x = e.offsetX
  const y = e.offsetY

  const link = hitLink(x, y)
  if (link) {
    state.links = state.links.filter(l => l.id !== link.id)
    if (state.selectedLinkId === link.id) state.selectedLinkId = null
    bumpLayoutVersion()
    return
  }

  const node = hitNode(x, y)
  if (!node) return

  if (y <= node.y + 24) {
    const t = prompt('Заголовок сущности:', node.title)
    if (t !== null && t.trim() !== '') {
      node.title = t.trim()
      bumpLayoutVersion()
    }
    return
  }

  const idx = Math.floor((y - (node.y + 40)) / 14)
  if (idx >= 0 && idx < node.fields.length) {
    editSingleField(node, idx)
    return
  }

  openEntityEditor(node)
}

canvas.oncontextmenu = e => {
  e.preventDefault()
  state.linkDraft = null
}

addEventListener('keydown', e => {
  if (e.key === 'Escape') {
    state.linkDraft = null
    if (editorEl.style.display === 'block') closeEntityEditor()
    state.selectedLinkId = null
  }
  if (e.key === '1') setTool('select')
  if (e.key === '2') setTool('node')
  if (e.key === '3') setTool('link')
})

/* ================= LOOP ================= */
function loop() {
  updateRefsCache()
  ensureRouted()

  ctx.clearRect(0, 0, canvas.width, canvas.height)
  drawBackgroundDots()

  state.links.forEach(drawLink)
  state.nodes.forEach(drawNode)

  // Пунктир при создании связи
  if (state.linkDraft && state.linkDraft.toPoint) {
    const a = state.linkDraft.from
    const p1 = intersection(a, state.linkDraft.toPoint)
    const p2 = state.linkDraft.toPoint
    ctx.strokeStyle = '#222'
    ctx.lineWidth = 1
    ctx.setLineDash([6, 6])
    ctx.beginPath()
    ctx.moveTo(p1.x, p1.y)
    ctx.lineTo(p2.x, p2.y)
    ctx.stroke()
    ctx.setLineDash([])
  }

  requestAnimationFrame(loop)
}
loop()
</script>

</body>
</html>
