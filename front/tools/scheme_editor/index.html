<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>ER Diagram – Crow's Foot</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: sans-serif; }
    #toolbar {
      position: fixed;
      top: 10px;
      left: 10px;
      background: #fff;
      border: 1px solid #ccc;
      padding: 6px;
      display: flex;
      gap: 6px;
      z-index: 10;
      user-select: none;
    }
    canvas { background: #f4f4f4; display: block; }
    button { cursor: pointer; }

    /* Панель редактора сущности (title + fields свободной формой) */
    #entity-editor {
      position: fixed;
      top: 70px;
      left: 10px;
      width: 340px;
      background: #fff;
      border: 1px solid #ccc;
      padding: 10px;
      z-index: 30;
      display: none;
      box-shadow: 0 6px 18px rgba(0,0,0,0.12);
    }
    #entity-editor h3 { margin: 0 0 8px 0; font-size: 14px; }
    #entity-editor label { display: block; font-size: 12px; margin: 8px 0 4px; }
    #entity-title-input {
      width: 100%;
      box-sizing: border-box;
      padding: 6px;
      font-size: 12px;
    }
    #entity-fields-text {
      width: 100%;
      height: 160px;
      box-sizing: border-box;
      padding: 6px;
      font-size: 12px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      resize: vertical;
    }
    #entity-editor .row { display: flex; gap: 8px; margin-top: 10px; }
    #entity-editor .row button { flex: 1; padding: 6px; font-size: 12px; }
    #entity-editor .hint { margin-top: 8px; font-size: 11px; color: #555; line-height: 1.3; }
    #entity-editor .error { margin-top: 8px; font-size: 11px; color: #b00020; display: none; white-space: pre-wrap; }
  </style>
</head>
<body>

<div id="toolbar">
  <button onclick="setTool('select')">Select</button>
  <button onclick="setTool('node')">Entity</button>
  <button onclick="setTool('link')">Link</button>
</div>

<!-- Редактор сущности: свободная форма для полей -->
<div id="entity-editor">
  <h3>Entity editor</h3>

  <label for="entity-title-input">Заголовок</label>
  <input id="entity-title-input" type="text" />

  <label for="entity-fields-text">Поля (по одному в строке)</label>
  <textarea id="entity-fields-text" placeholder="id:int [PK]
user_id:int [FK]
email:varchar"></textarea>

  <div class="row">
    <button onclick="applyEntityEditor()">Применить</button>
    <button onclick="closeEntityEditor()">Отмена</button>
  </div>

  <div class="hint">
    Формат строк: <b>name:type [meta]</b><br/>
    Примеры meta: PK, FK, UQ, NN, IDX и т.п. (любой текст в скобках).<br/>
    Пустые строки игнорируются.
  </div>

  <div id="entity-editor-error" class="error"></div>
</div>

<canvas id="canvas"></canvas>

<script>
/* ================= SETUP ================= */
const canvas = document.getElementById('canvas')
const ctx = canvas.getContext('2d')

let bgPattern = null

/* Функция: подгоняет размеры canvas под окно браузера */
function resize() {
  canvas.width = innerWidth
  canvas.height = innerHeight
  bgPattern = null
}
addEventListener('resize', resize)
resize()

/* ================= STATE ================= */
const state = {
  nodes: [],
  links: [],
  tool: 'select',
  selected: null,
  dragging: false,
  dragOffset: { x: 0, y: 0 },
  linkDraft: null,      // { from: Node, toPoint: {x,y} }
  editingNode: null,    // Node, которую сейчас редактируем в панели
  refsCache: new Map()  // Map<nodeId, string[]> список заголовков referenced (включая вложенные)
}

/* Функция: переключает инструмент (select/node/link) */
function setTool(tool) {
  state.tool = tool
  // При уходе с link — отменяем черновик связи
  if (tool !== 'link') state.linkDraft = null
}

/* ================= BACKGROUND DOT GRID ================= */
const CM_PX = 37.8
const GRID_SPACING = Math.round(CM_PX)
const DOT_RADIUS = 1

/* Функция: создаёт паттерн из точек для заливки фона */
function makeDotPattern() {
  const p = document.createElement('canvas')
  p.width = GRID_SPACING
  p.height = GRID_SPACING
  const pctx = p.getContext('2d')

  pctx.clearRect(0, 0, p.width, p.height)
  pctx.beginPath()
  pctx.arc(GRID_SPACING / 2, GRID_SPACING / 2, DOT_RADIUS, 0, Math.PI * 2)
  pctx.fillStyle = 'rgba(0,0,0,0.18)'
  pctx.fill()

  return ctx.createPattern(p, 'repeat')
}

/* Функция: рисует фон рабочей области точками */
function drawBackgroundDots() {
  if (!bgPattern) bgPattern = makeDotPattern()
  ctx.save()
  ctx.setTransform(1, 0, 0, 1, 0, 0)
  ctx.fillStyle = bgPattern
  ctx.fillRect(0, 0, canvas.width, canvas.height)
  ctx.restore()
}

/* ================= HELPERS ================= */
/* Функция: находит entity под курсором (если попали в её прямоугольник) */
function hitNode(x, y) {
  for (let i = state.nodes.length - 1; i >= 0; i--) {
    const n = state.nodes[i]
    if (x >= n.x && x <= n.x + n.width &&
        y >= n.y && y <= n.y + n.height) return n
  }
  return null
}

/* Функция: возвращает центр прямоугольника entity */
function center(n) {
  return { x: n.x + n.width / 2, y: n.y + n.height / 2 }
}

/* Функция: вычисляет высоту entity по количеству строк (поля + refs) */
function calcNodeHeight(n) {
  const line = 14
  const header = 24
  const padding = 16

  const fieldsLines = n.fields.length
  const refs = state.refsCache.get(n.id) || []
  const refsHeaderLines = refs.length > 0 ? 1 : 0
  const refsLines = refs.length

  // поля начинают рисоваться с y = node.y + 40 (т.е. header + 16)
  // поэтому формула ниже держит совместимость с текущим layout
  const totalLines = fieldsLines + refsHeaderLines + refsLines
  return header + padding + totalLines * line
}

/* ================= GEOMETRY ================= */
/* Функция: вычисляет точку пересечения линии с границей прямоугольника entity */
function intersection(rect, target) {
  const cx = rect.x + rect.width / 2
  const cy = rect.y + rect.height / 2
  const dx = target.x - cx
  const dy = target.y - cy
  const adx = Math.abs(dx) || 0.00001
  const ady = Math.abs(dy) || 0.00001
  const scale = Math.min(rect.width / 2 / adx, rect.height / 2 / ady)
  return { x: cx + dx * scale, y: cy + dy * scale }
}

/* ================= CARDINALITY ================= */
/* Функция: рисует "воронью лапку" (many) */
function drawCrowFoot(x, y, angle) {
  const s = 10, sp = Math.PI / 6
  for (let i of [-1, 0, 1]) {
    ctx.beginPath()
    ctx.moveTo(x, y)
    ctx.lineTo(
      x + Math.cos(angle + sp * i) * s,
      y + Math.sin(angle + sp * i) * s
    )
    ctx.stroke()
  }
}

/* Функция: рисует "единицу" (one) */
function drawOne(x, y, angle) {
  const s = 8, a = angle + Math.PI / 2
  ctx.beginPath()
  ctx.moveTo(x + Math.cos(a) * s, y + Math.sin(a) * s)
  ctx.lineTo(x - Math.cos(a) * s, y - Math.sin(a) * s)
  ctx.stroke()
}

/* Функция: рисует "ноль" (optional) */
function drawZero(x, y) {
  ctx.beginPath()
  ctx.arc(x, y, 4, 0, Math.PI * 2)
  ctx.stroke()
}

/* Функция: рисует кардинальность по типу */
function drawCardinality(type, x, y, angle) {
  if (type === 'one') drawOne(x, y, angle)
  if (type === 'many') drawCrowFoot(x, y, angle)
  if (type === 'zero-one') {
    drawZero(x, y)
    drawOne(x, y, angle)
  }
}

/* ================= REFERENCES (TRANSITIVE) ================= */
/* Функция: строит карту смежности графа ссылок (from -> [to...]) */
function buildAdjacency() {
  const adj = new Map()
  for (const l of state.links) {
    if (!adj.has(l.from)) adj.set(l.from, new Set())
    adj.get(l.from).add(l.to)
  }
  return adj
}

/* Функция: вычисляет достижимые узлы из startId (транзитивно), исключая сам startId */
function collectReachable(adj, startId) {
  const visited = new Set()
  const stack = [startId]

  // Мы не хотим включать startId в результат
  visited.add(startId)

  while (stack.length) {
    const v = stack.pop()
    const next = adj.get(v)
    if (!next) continue
    for (const u of next) {
      if (visited.has(u)) continue
      visited.add(u)
      stack.push(u)
    }
  }

  visited.delete(startId)
  return visited
}

/* Функция: обновляет кэш refsCache для всех entity (список заголовков referenced, включая вложенные) */
function updateRefsCache() {
  const adj = buildAdjacency()

  const titleById = new Map()
  for (const n of state.nodes) titleById.set(n.id, n.title)

  const cache = new Map()
  for (const n of state.nodes) {
    const reachable = collectReachable(adj, n.id)
    const titles = []

    for (const id of reachable) {
      const t = titleById.get(id)
      if (t) titles.push(t)
    }

    titles.sort((a, b) => a.localeCompare(b, 'ru'))
    cache.set(n.id, titles)
  }

  state.refsCache = cache
}

/* ================= DRAW ================= */
/* Функция: рисует entity (непрозрачный фон + заголовок + поля + references) */
function drawNode(n) {
  n.height = calcNodeHeight(n)

  // Непрозрачный фон entity (чтобы сетка не просвечивала)
  ctx.fillStyle = '#ffffff'
  ctx.fillRect(n.x, n.y, n.width, n.height)

  // Рамка
  ctx.strokeStyle = '#222'
  ctx.strokeRect(n.x, n.y, n.width, n.height)

  // Header
  ctx.fillStyle = '#eeeeee'
  ctx.fillRect(n.x, n.y, n.width, 24)
  ctx.strokeRect(n.x, n.y, n.width, 24)

  // Title
  ctx.fillStyle = '#000'
  ctx.font = 'bold 12px sans-serif'
  ctx.fillText(n.title, n.x + 6, n.y + 16)

  // Fields
  ctx.font = '12px monospace'
  const lineH = 14
  let y = n.y + 40

  n.fields.forEach((f) => {
    ctx.fillText(
      `${f.name}: ${f.type}${f.meta ? ' [' + f.meta + ']' : ''}`,
      n.x + 6,
      y
    )
    y += lineH
  })

  // References (список заголовков сущностей, на которые ссылаемся, включая вложенные)
  const refs = state.refsCache.get(n.id) || []
  if (refs.length > 0) {
    // небольшая визуальная граница
    ctx.strokeStyle = 'rgba(0,0,0,0.15)'
    ctx.beginPath()
    ctx.moveTo(n.x + 4, y + 4)
    ctx.lineTo(n.x + n.width - 4, y + 4)
    ctx.stroke()

    y += lineH

    ctx.fillStyle = '#000'
    ctx.font = 'bold 12px sans-serif'
    ctx.fillText('References:', n.x + 6, y)
    y += lineH

    ctx.font = '12px monospace'
    refs.forEach((t) => {
      ctx.fillText(`→ ${t}`, n.x + 6, y)
      y += lineH
    })
  }
}

/* Функция: рисует связь между entity с кардинальностями на концах */
function drawLink(l) {
  const a = state.nodes.find(n => n.id === l.from)
  const b = state.nodes.find(n => n.id === l.to)
  if (!a || !b) return

  const p1 = intersection(a, center(b))
  const p2 = intersection(b, center(a))

  ctx.strokeStyle = '#222'
  ctx.beginPath()
  ctx.moveTo(p1.x, p1.y)
  ctx.lineTo(p2.x, p2.y)
  ctx.stroke()

  const ang = Math.atan2(p2.y - p1.y, p2.x - p1.x)
  drawCardinality(l.fromCardinality, p1.x, p1.y, ang)
  drawCardinality(l.toCardinality, p2.x, p2.y, ang + Math.PI)
}

/* ================= ENTITY EDITOR (FREE FORM) ================= */
const editorEl = document.getElementById('entity-editor')
const editorTitleInput = document.getElementById('entity-title-input')
const editorFieldsText = document.getElementById('entity-fields-text')
const editorErrorEl = document.getElementById('entity-editor-error')

/* Функция: открывает панель редактирования entity (title + поля свободной формой) */
function openEntityEditor(node) {
  state.editingNode = node
  editorTitleInput.value = node.title
  editorFieldsText.value = stringifyFields(node.fields)
  editorErrorEl.style.display = 'none'
  editorErrorEl.textContent = ''
  editorEl.style.display = 'block'
  editorTitleInput.focus()
}

/* Функция: закрывает панель редактирования entity */
function closeEntityEditor() {
  state.editingNode = null
  editorEl.style.display = 'none'
  editorErrorEl.style.display = 'none'
  editorErrorEl.textContent = ''
}

/* Функция: применяет изменения из панели (title + поля) к entity */
function applyEntityEditor() {
  const node = state.editingNode
  if (!node) return

  const newTitle = editorTitleInput.value.trim()
  if (newTitle) node.title = newTitle

  const parsed = parseFieldsText(editorFieldsText.value)
  if (!parsed.ok) {
    editorErrorEl.style.display = 'block'
    editorErrorEl.textContent = parsed.error
    return
  }

  node.fields = parsed.fields
  closeEntityEditor()
}

/* Функция: превращает массив полей в текст (по одному полю на строку) */
function stringifyFields(fields) {
  return fields.map(f => `${f.name}:${f.type}${f.meta ? ' [' + f.meta + ']' : ''}`).join('\n')
}

/* Функция: парсит поля из свободного текста (строки формата name:type [meta]) */
function parseFieldsText(text) {
  const lines = text.split(/\r?\n/)
  const fields = []
  const errors = []

  for (let i = 0; i < lines.length; i++) {
    const raw = lines[i].trim()
    if (!raw) continue

    const m = raw.match(/^(\w+)\s*:\s*([A-Za-z0-9_]+)(?:\s*\[(.+)\])?$/)
    if (!m) {
      errors.push(`Строка ${i + 1}: неверный формат -> "${lines[i]}"`)
      continue
    }

    fields.push({ name: m[1], type: m[2], meta: m[3] ? m[3].trim() : null })
  }

  if (errors.length) return { ok: false, error: errors.join('\n') }
  if (fields.length === 0) fields.push({ name: 'id', type: 'int', meta: 'PK' })
  return { ok: true, fields }
}

/* ================= SINGLE FIELD EDIT ================= */
/* Функция: редактирует одно поле entity через prompt */
function editSingleField(node, index) {
  const f = node.fields[index]
  const current = `${f.name}:${f.type}${f.meta ? ' [' + f.meta + ']' : ''}`
  const value = prompt('Поле (name:type [meta]):', current)
  if (value === null) return

  const v = value.trim()
  if (!v) return

  const m = v.match(/^(\w+)\s*:\s*([A-Za-z0-9_]+)(?:\s*\[(.+)\])?$/)
  if (!m) {
    alert('Неверный формат. Пример: user_id:int [FK]')
    return
  }

  f.name = m[1]
  f.type = m[2]
  f.meta = m[3] ? m[3].trim() : null
}

/* ================= EVENTS ================= */
/* Функция: обработчик нажатия мыши (создание entity, перетаскивание, создание связей) */
canvas.onmousedown = e => {
  const x = e.offsetX
  const y = e.offsetY
  const hit = hitNode(x, y)

  // Инструмент: создание сущности
  if (state.tool === 'node') {
    state.nodes.push({
      id: crypto.randomUUID(),
      x, y,
      width: 220,              // чуть шире, чтобы refs помещались лучше
      title: 'Entity',
      fields: [{ name: 'id', type: 'int', meta: 'PK' }]
    })
    return
  }

  // Инструмент: создание связей (2 клика)
  if (state.tool === 'link') {
    if (hit) {
      if (!state.linkDraft) {
        state.linkDraft = { from: hit, toPoint: { x, y } }
      } else if (state.linkDraft.from !== hit) {
        state.links.push({
          id: crypto.randomUUID(),
          from: state.linkDraft.from.id,
          to: hit.id,
          fromCardinality: 'one',
          toCardinality: 'many'
        })
        state.linkDraft = null
      }
      return
    }
    state.linkDraft = null
    return
  }

  // Инструмент: выбор и перетаскивание
  if (state.tool === 'select' && hit) {
    state.selected = hit
    state.dragging = true
    state.dragOffset = { x: x - hit.x, y: y - hit.y }
  }
}

/* Функция: обработчик движения мыши (перетаскивание + обновление пунктира связи) */
canvas.onmousemove = e => {
  const x = e.offsetX
  const y = e.offsetY

  if (state.linkDraft) state.linkDraft.toPoint = { x, y }

  if (state.dragging && state.selected) {
    state.selected.x = x - state.dragOffset.x
    state.selected.y = y - state.dragOffset.y
  }
}

/* Функция: обработчик отпускания кнопки мыши (останавливает drag) */
canvas.onmouseup = () => {
  state.dragging = false
  state.selected = null
}

/* Функция: обработчик двойного клика (редактирование title/поля/свободная форма) */
canvas.ondblclick = e => {
  const x = e.offsetX
  const y = e.offsetY
  const node = hitNode(x, y)
  if (!node) return

  // двойной клик по header: редактируем заголовок
  if (y <= node.y + 24) {
    const t = prompt('Заголовок сущности:', node.title)
    if (t !== null && t.trim() !== '') node.title = t.trim()
    return
  }

  // если клик по строке поля — редактируем одно поле
  const idx = Math.floor((y - (node.y + 40)) / 14)
  if (idx >= 0 && idx < node.fields.length) {
    editSingleField(node, idx)
    return
  }

  // иначе — открываем свободную форму
  openEntityEditor(node)
}

/* Функция: обработчик правой кнопки мыши (отменяет черновик связи, не показывает меню) */
canvas.oncontextmenu = e => {
  e.preventDefault()
  state.linkDraft = null
}

/* Функция: обработчик клавиатуры (Esc отменяет черновик связи/закрывает редактор) */
addEventListener('keydown', e => {
  if (e.key === 'Escape') {
    state.linkDraft = null
    if (editorEl.style.display === 'block') closeEntityEditor()
  }
})

/* ================= LOOP ================= */
/* Функция: основной цикл отрисовки canvas */
function loop() {
  // 1) обновляем кэш references (включая вложенные) перед вычислением высот и отрисовкой
  updateRefsCache()

  // 2) рисуем
  ctx.clearRect(0, 0, canvas.width, canvas.height)
  drawBackgroundDots()

  state.links.forEach(drawLink)
  state.nodes.forEach(drawNode)

  // временная пунктирная линия при создании связи
  if (state.linkDraft && state.linkDraft.toPoint) {
    const p1 = intersection(state.linkDraft.from, state.linkDraft.toPoint)
    const p2 = state.linkDraft.toPoint
    ctx.setLineDash([6, 6])
    ctx.beginPath()
    ctx.moveTo(p1.x, p1.y)
    ctx.lineTo(p2.x, p2.y)
    ctx.stroke()
    ctx.setLineDash([])
  }

  requestAnimationFrame(loop)
}
loop()
</script>

</body>
</html>
