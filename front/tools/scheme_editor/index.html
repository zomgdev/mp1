<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>ER Diagram – Crow's Foot</title>
  <style>
    :root{
      --panel-bg:#fff;
      --panel-border:#d7d7d7;
      --panel-shadow: 0 10px 24px rgba(0,0,0,.10);
      --icon:#2b2b2b;
      --icon-muted:#6a6a6a;
      --accent:#1e88e5;
      --hover:#f2f5f8;
    }

    body { margin: 0; overflow: hidden; font-family: sans-serif; }
    canvas { background: #f4f4f4; display: block; }

    /* ================= TOOLBAR (VERTICAL) ================= */
    #toolpanel {
      position: fixed;
      top: 12px;
      left: 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      padding: 10px;
      background: var(--panel-bg);
      border: 1px solid var(--panel-border);
      border-radius: 12px;
      box-shadow: var(--panel-shadow);
      z-index: 10;
      user-select: none;
    }

    .toolbtn {
      width: 44px;
      height: 44px;
      border: 1px solid transparent;
      border-radius: 10px;
      background: transparent;
      display: grid;
      place-items: center;
      cursor: pointer;
      position: relative;
      outline: none;
    }

    .toolbtn:hover {
      background: var(--hover);
      border-color: #e8e8e8;
    }

    .toolbtn:active {
      transform: translateY(1px);
    }

    .toolbtn.active {
      background: rgba(30,136,229,0.12);
      border-color: rgba(30,136,229,0.35);
    }

    .toolbtn svg {
      width: 22px;
      height: 22px;
      stroke: var(--icon);
      fill: none;
      stroke-width: 2;
      stroke-linecap: round;
      stroke-linejoin: round;
    }

    .toolbtn.active svg {
      stroke: var(--accent);
    }

    /* Tooltip */
    .toolbtn[data-tip]::after {
      content: attr(data-tip);
      position: absolute;
      left: 54px;
      top: 50%;
      transform: translateY(-50%);
      background: rgba(20,20,20,0.92);
      color: #fff;
      font-size: 12px;
      padding: 6px 8px;
      border-radius: 8px;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity .12s ease, transform .12s ease;
    }
    .toolbtn[data-tip]::before {
      content: "";
      position: absolute;
      left: 48px;
      top: 50%;
      transform: translateY(-50%);
      border: 6px solid transparent;
      border-right-color: rgba(20,20,20,0.92);
      opacity: 0;
      pointer-events: none;
      transition: opacity .12s ease;
    }

    .toolbtn:hover::after,
    .toolbtn:hover::before {
      opacity: 1;
    }

    /* Панель редактора сущности (title + fields свободной формой) */
    #entity-editor {
      position: fixed;
      top: 70px;
      left: 84px; /* чтобы не перекрывать вертикальную панель */
      width: 360px;
      background: #fff;
      border: 1px solid #ccc;
      padding: 10px;
      z-index: 30;
      display: none;
      box-shadow: 0 6px 18px rgba(0,0,0,0.12);
      border-radius: 12px;
    }
    #entity-editor h3 { margin: 0 0 8px 0; font-size: 14px; }
    #entity-editor label { display: block; font-size: 12px; margin: 8px 0 4px; }
    #entity-title-input {
      width: 100%;
      box-sizing: border-box;
      padding: 6px;
      font-size: 12px;
    }
    #entity-fields-text {
      width: 100%;
      height: 160px;
      box-sizing: border-box;
      padding: 6px;
      font-size: 12px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      resize: vertical;
    }
    #entity-editor .row { display: flex; gap: 8px; margin-top: 10px; }
    #entity-editor .row button { flex: 1; padding: 8px; font-size: 12px; cursor: pointer; }
    #entity-editor .hint { margin-top: 8px; font-size: 11px; color: #555; line-height: 1.3; }
    #entity-editor .error { margin-top: 8px; font-size: 11px; color: #b00020; display: none; white-space: pre-wrap; }
  </style>
</head>
<body>

<!-- ================= VERTICAL TOOL PANEL ================= -->
<div id="toolpanel" aria-label="Tools">
  <!-- Select -->
  <button class="toolbtn active" id="tool-select" data-tool="select" data-tip="Выбор / Перемещение (Select)">
    <svg viewBox="0 0 24 24" aria-hidden="true">
      <!-- cursor arrow -->
      <path d="M4 3l7.5 17 2.2-6 6 0.6L4 3z"></path>
    </svg>
  </button>

  <!-- Entity -->
  <button class="toolbtn" id="tool-node" data-tool="node" data-tip="Добавить сущность (Entity)">
    <svg viewBox="0 0 24 24" aria-hidden="true">
      <rect x="5" y="6" width="14" height="12" rx="2"></rect>
      <path d="M5 10h14"></path>
      <path d="M8 14h8"></path>
    </svg>
  </button>

  <!-- Link -->
  <button class="toolbtn" id="tool-link" data-tool="link" data-tip="Связь (Link)">
    <svg viewBox="0 0 24 24" aria-hidden="true">
      <path d="M7 12a4 4 0 0 1 4-4h2"></path>
      <path d="M17 12a4 4 0 0 1-4 4h-2"></path>
      <path d="M10 12h4"></path>
      <path d="M14.5 8.5l2-2a3 3 0 0 1 4.2 4.2l-2 2"></path>
      <path d="M9.5 15.5l-2 2a3 3 0 0 1-4.2-4.2l2-2"></path>
    </svg>
  </button>
</div>

<!-- Редактор сущности: свободная форма для полей -->
<div id="entity-editor">
  <h3>Entity editor</h3>

  <label for="entity-title-input">Заголовок</label>
  <input id="entity-title-input" type="text" />

  <label for="entity-fields-text">Поля (по одному в строке)</label>
  <textarea id="entity-fields-text" placeholder="id:int [PK]
user_id:int [FK]
email:varchar"></textarea>

  <div class="row">
    <button onclick="applyEntityEditor()">Применить</button>
    <button onclick="closeEntityEditor()">Отмена</button>
  </div>

  <div class="hint">
    Формат строк: <b>name:type [meta]</b><br/>
    Примеры meta: PK, FK, UQ, NN, IDX и т.п.<br/>
    Пустые строки игнорируются.
  </div>

  <div id="entity-editor-error" class="error"></div>
</div>

<canvas id="canvas"></canvas>

<script>
/* ================= SETUP ================= */
const canvas = document.getElementById('canvas')
const ctx = canvas.getContext('2d')
let bgPattern = null

/* Функция: подгоняет размеры canvas под окно браузера */
function resize() {
  canvas.width = innerWidth
  canvas.height = innerHeight
  bgPattern = null
}
addEventListener('resize', resize)
resize()

/* ================= STATE ================= */
const state = {
  nodes: [],
  links: [],
  tool: 'select',
  selected: null,            // выбранная entity для drag
  selectedLinkId: null,      // выбранная связь (для подсветки)
  dragging: false,
  dragOffset: { x: 0, y: 0 },
  linkDraft: null,           // { from: Node, toPoint: {x,y} }
  editingNode: null,         // Node, которую сейчас редактируем в панели
  refsCache: new Map()       // Map<nodeId, string[]>
}

/* Функция: применяет активный класс для кнопок инструмента */
function setActiveToolButton(tool) {
  document.querySelectorAll('.toolbtn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.tool === tool)
  })
}

/* Функция: переключает инструмент (select/node/link) */
function setTool(tool) {
  state.tool = tool
  if (tool !== 'link') state.linkDraft = null
  setActiveToolButton(tool)
}

/* Функция: подключает обработчики к вертикальной панели инструментов */
function initToolPanel() {
  document.querySelectorAll('.toolbtn').forEach(btn => {
    btn.addEventListener('click', () => setTool(btn.dataset.tool))
  })
}
initToolPanel()

/* ================= BACKGROUND DOT GRID ================= */
const CM_PX = 37.8
const GRID_SPACING = Math.round(CM_PX)
const DOT_RADIUS = 1

/* Функция: создаёт паттерн из точек для заливки фона */
function makeDotPattern() {
  const p = document.createElement('canvas')
  p.width = GRID_SPACING
  p.height = GRID_SPACING
  const pctx = p.getContext('2d')

  pctx.clearRect(0, 0, p.width, p.height)
  pctx.beginPath()
  pctx.arc(GRID_SPACING / 2, GRID_SPACING / 2, DOT_RADIUS, 0, Math.PI * 2)
  pctx.fillStyle = 'rgba(0,0,0,0.18)'
  pctx.fill()

  return ctx.createPattern(p, 'repeat')
}

/* Функция: рисует фон рабочей области точками */
function drawBackgroundDots() {
  if (!bgPattern) bgPattern = makeDotPattern()
  ctx.save()
  ctx.setTransform(1, 0, 0, 1, 0, 0)
  ctx.fillStyle = bgPattern
  ctx.fillRect(0, 0, canvas.width, canvas.height)
  ctx.restore()
}

/* ================= HELPERS ================= */
/* Функция: находит entity под курсором */
function hitNode(x, y) {
  for (let i = state.nodes.length - 1; i >= 0; i--) {
    const n = state.nodes[i]
    if (x >= n.x && x <= n.x + n.width &&
        y >= n.y && y <= n.y + n.height) return n
  }
  return null
}

/* Функция: возвращает центр прямоугольника entity */
function center(n) {
  return { x: n.x + n.width / 2, y: n.y + n.height / 2 }
}

/* Функция: вычисляет высоту entity по количеству строк (поля + refs) */
function calcNodeHeight(n) {
  const line = 14
  const header = 24
  const padding = 16

  const fieldsLines = n.fields.length
  const refs = state.refsCache.get(n.id) || []
  const refsHeaderLines = refs.length > 0 ? 1 : 0
  const refsLines = refs.length

  const totalLines = fieldsLines + refsHeaderLines + refsLines
  return header + padding + totalLines * line
}

/* ================= GEOMETRY ================= */
/* Функция: вычисляет точку пересечения линии с границей прямоугольника entity */
function intersection(rect, target) {
  const cx = rect.x + rect.width / 2
  const cy = rect.y + rect.height / 2
  const dx = target.x - cx
  const dy = target.y - cy
  const adx = Math.abs(dx) || 0.00001
  const ady = Math.abs(dy) || 0.00001
  const scale = Math.min(rect.width / 2 / adx, rect.height / 2 / ady)
  return { x: cx + dx * scale, y: cy + dy * scale }
}

/* Функция: расстояние от точки до отрезка (для hit-test связи) */
function distPointToSegment(px, py, x1, y1, x2, y2) {
  const vx = x2 - x1
  const vy = y2 - y1
  const wx = px - x1
  const wy = py - y1

  const c1 = wx * vx + wy * vy
  if (c1 <= 0) return Math.hypot(px - x1, py - y1)

  const c2 = vx * vx + vy * vy
  if (c2 <= c1) return Math.hypot(px - x2, py - y2)

  const t = c1 / c2
  const projx = x1 + t * vx
  const projy = y1 + t * vy
  return Math.hypot(px - projx, py - projy)
}

/* Функция: hit-test по связи. Возвращает link или null */
function hitLink(x, y) {
  const TH = 7

  for (let i = state.links.length - 1; i >= 0; i--) {
    const l = state.links[i]
    const a = state.nodes.find(n => n.id === l.from)
    const b = state.nodes.find(n => n.id === l.to)
    if (!a || !b) continue

    const p1 = intersection(a, center(b))
    const p2 = intersection(b, center(a))

    const d = distPointToSegment(x, y, p1.x, p1.y, p2.x, p2.y)
    if (d <= TH) return l
  }
  return null
}

/* ================= CARDINALITY ================= */
/* Функция: рисует "воронью лапку" (many) */
function drawCrowFoot(x, y, angle) {
  const s = 10, sp = Math.PI / 6
  for (let i of [-1, 0, 1]) {
    ctx.beginPath()
    ctx.moveTo(x, y)
    ctx.lineTo(
      x + Math.cos(angle + sp * i) * s,
      y + Math.sin(angle + sp * i) * s
    )
    ctx.stroke()
  }
}

/* Функция: рисует "единицу" (one) */
function drawOne(x, y, angle) {
  const s = 8, a = angle + Math.PI / 2
  ctx.beginPath()
  ctx.moveTo(x + Math.cos(a) * s, y + Math.sin(a) * s)
  ctx.lineTo(x - Math.cos(a) * s, y - Math.sin(a) * s)
  ctx.stroke()
}

/* Функция: рисует "ноль" (optional) */
function drawZero(x, y) {
  ctx.beginPath()
  ctx.arc(x, y, 4, 0, Math.PI * 2)
  ctx.stroke()
}

/* Функция: рисует кардинальность по типу */
function drawCardinality(type, x, y, angle) {
  if (type === 'one') drawOne(x, y, angle)
  if (type === 'many') drawCrowFoot(x, y, angle)
  if (type === 'zero-one') {
    drawZero(x, y)
    drawOne(x, y, angle)
  }
}

/* ================= REFERENCES (TRANSITIVE) ================= */
/* Функция: строит карту смежности графа ссылок (from -> [to...]) */
function buildAdjacency() {
  const adj = new Map()
  for (const l of state.links) {
    if (!adj.has(l.from)) adj.set(l.from, new Set())
    adj.get(l.from).add(l.to)
  }
  return adj
}

/* Функция: вычисляет достижимые узлы из startId (транзитивно) */
function collectReachable(adj, startId) {
  const visited = new Set([startId])
  const stack = [startId]

  while (stack.length) {
    const v = stack.pop()
    const next = adj.get(v)
    if (!next) continue
    for (const u of next) {
      if (visited.has(u)) continue
      visited.add(u)
      stack.push(u)
    }
  }

  visited.delete(startId)
  return visited
}

/* Функция: обновляет кэш refsCache для всех entity */
function updateRefsCache() {
  const adj = buildAdjacency()
  const titleById = new Map()
  for (const n of state.nodes) titleById.set(n.id, n.title)

  const cache = new Map()
  for (const n of state.nodes) {
    const reachable = collectReachable(adj, n.id)
    const titles = []
    for (const id of reachable) {
      const t = titleById.get(id)
      if (t) titles.push(t)
    }
    titles.sort((a, b) => a.localeCompare(b, 'ru'))
    cache.set(n.id, titles)
  }
  state.refsCache = cache
}

/* ================= DRAW ================= */
/* Функция: рисует entity */
function drawNode(n) {
  n.height = calcNodeHeight(n)

  ctx.fillStyle = '#ffffff'
  ctx.fillRect(n.x, n.y, n.width, n.height)

  ctx.strokeStyle = '#222'
  ctx.lineWidth = 1
  ctx.strokeRect(n.x, n.y, n.width, n.height)

  ctx.fillStyle = '#eeeeee'
  ctx.fillRect(n.x, n.y, n.width, 24)
  ctx.strokeRect(n.x, n.y, n.width, 24)

  ctx.fillStyle = '#000'
  ctx.font = 'bold 12px sans-serif'
  ctx.fillText(n.title, n.x + 6, n.y + 16)

  ctx.font = '12px monospace'
  const lineH = 14
  let y = n.y + 40

  n.fields.forEach((f) => {
    ctx.fillText(
      `${f.name}: ${f.type}${f.meta ? ' [' + f.meta + ']' : ''}`,
      n.x + 6,
      y
    )
    y += lineH
  })

  const refs = state.refsCache.get(n.id) || []
  if (refs.length > 0) {
    ctx.strokeStyle = 'rgba(0,0,0,0.15)'
    ctx.beginPath()
    ctx.moveTo(n.x + 4, y + 4)
    ctx.lineTo(n.x + n.width - 4, y + 4)
    ctx.stroke()

    y += lineH

    ctx.fillStyle = '#000'
    ctx.font = 'bold 12px sans-serif'
    ctx.fillText('References:', n.x + 6, y)
    y += lineH

    ctx.font = '12px monospace'
    refs.forEach((t) => {
      ctx.fillText(`→ ${t}`, n.x + 6, y)
      y += lineH
    })
  }
}

/* Функция: рисует связь (с подсветкой выбранной) */
function drawLink(l) {
  const a = state.nodes.find(n => n.id === l.from)
  const b = state.nodes.find(n => n.id === l.to)
  if (!a || !b) return

  const p1 = intersection(a, center(b))
  const p2 = intersection(b, center(a))

  const selected = (state.selectedLinkId === l.id)

  ctx.strokeStyle = selected ? '#1e88e5' : '#222'
  ctx.lineWidth = selected ? 2 : 1

  ctx.beginPath()
  ctx.moveTo(p1.x, p1.y)
  ctx.lineTo(p2.x, p2.y)
  ctx.stroke()

  const ang = Math.atan2(p2.y - p1.y, p2.x - p1.x)
  drawCardinality(l.fromCardinality, p1.x, p1.y, ang)
  drawCardinality(l.toCardinality, p2.x, p2.y, ang + Math.PI)

  ctx.lineWidth = 1
}

/* ================= ENTITY EDITOR (FREE FORM) ================= */
const editorEl = document.getElementById('entity-editor')
const editorTitleInput = document.getElementById('entity-title-input')
const editorFieldsText = document.getElementById('entity-fields-text')
const editorErrorEl = document.getElementById('entity-editor-error')

/* Функция: открывает панель редактирования entity */
function openEntityEditor(node) {
  state.editingNode = node
  editorTitleInput.value = node.title
  editorFieldsText.value = stringifyFields(node.fields)
  editorErrorEl.style.display = 'none'
  editorErrorEl.textContent = ''
  editorEl.style.display = 'block'
  editorTitleInput.focus()
}

/* Функция: закрывает панель редактирования entity */
function closeEntityEditor() {
  state.editingNode = null
  editorEl.style.display = 'none'
  editorErrorEl.style.display = 'none'
  editorErrorEl.textContent = ''
}

/* Функция: применяет изменения из панели */
function applyEntityEditor() {
  const node = state.editingNode
  if (!node) return

  const newTitle = editorTitleInput.value.trim()
  if (newTitle) node.title = newTitle

  const parsed = parseFieldsText(editorFieldsText.value)
  if (!parsed.ok) {
    editorErrorEl.style.display = 'block'
    editorErrorEl.textContent = parsed.error
    return
  }

  node.fields = parsed.fields
  closeEntityEditor()
}

/* Функция: превращает массив полей в текст */
function stringifyFields(fields) {
  return fields.map(f => `${f.name}:${f.type}${f.meta ? ' [' + f.meta + ']' : ''}`).join('\n')
}

/* Функция: парсит поля из свободного текста */
function parseFieldsText(text) {
  const lines = text.split(/\r?\n/)
  const fields = []
  const errors = []

  for (let i = 0; i < lines.length; i++) {
    const raw = lines[i].trim()
    if (!raw) continue

    const m = raw.match(/^(\w+)\s*:\s*([A-Za-z0-9_]+)(?:\s*\[(.+)\])?$/)
    if (!m) {
      errors.push(`Строка ${i + 1}: неверный формат -> "${lines[i]}"`)
      continue
    }
    fields.push({ name: m[1], type: m[2], meta: m[3] ? m[3].trim() : null })
  }

  if (errors.length) return { ok: false, error: errors.join('\n') }
  if (fields.length === 0) fields.push({ name: 'id', type: 'int', meta: 'PK' })
  return { ok: true, fields }
}

/* ================= SINGLE FIELD EDIT ================= */
/* Функция: редактирует одно поле entity через prompt */
function editSingleField(node, index) {
  const f = node.fields[index]
  const current = `${f.name}:${f.type}${f.meta ? ' [' + f.meta + ']' : ''}`
  const value = prompt('Поле (name:type [meta]):', current)
  if (value === null) return

  const v = value.trim()
  if (!v) return

  const m = v.match(/^(\w+)\s*:\s*([A-Za-z0-9_]+)(?:\s*\[(.+)\])?$/)
  if (!m) {
    alert('Неверный формат. Пример: user_id:int [FK]')
    return
  }

  f.name = m[1]
  f.type = m[2]
  f.meta = m[3] ? m[3].trim() : null
}

/* ================= EVENTS ================= */
/* Функция: обработчик нажатия мыши */
canvas.onmousedown = e => {
  const x = e.offsetX
  const y = e.offsetY

  // В режиме Select: сначала проверяем попадание по связи (выделение)
  if (state.tool === 'select') {
    const link = hitLink(x, y)
    if (link) {
      state.selectedLinkId = link.id
      state.dragging = false
      state.selected = null
      return
    }
  }

  const hit = hitNode(x, y)

  // Инструмент: создание сущности
  if (state.tool === 'node') {
    state.nodes.push({
      id: crypto.randomUUID(),
      x, y,
      width: 220,
      title: 'Entity',
      fields: [{ name: 'id', type: 'int', meta: 'PK' }]
    })
    return
  }

  // Инструмент: создание связей (2 клика)
  if (state.tool === 'link') {
    if (hit) {
      if (!state.linkDraft) {
        state.linkDraft = { from: hit, toPoint: { x, y } }
      } else if (state.linkDraft.from !== hit) {
        state.links.push({
          id: crypto.randomUUID(),
          from: state.linkDraft.from.id,
          to: hit.id,
          fromCardinality: 'one',
          toCardinality: 'many'
        })
        state.linkDraft = null
      }
      return
    }
    state.linkDraft = null
    return
  }

  // Инструмент: выбор и перетаскивание
  if (state.tool === 'select') {
    if (hit) {
      state.selected = hit
      state.dragging = true
      state.dragOffset = { x: x - hit.x, y: y - hit.y }
      state.selectedLinkId = null
      return
    }
    // клик в пустоту — снять выделение связи/узла
    state.selectedLinkId = null
    state.selected = null
  }
}

/* Функция: обработчик движения мыши */
canvas.onmousemove = e => {
  const x = e.offsetX
  const y = e.offsetY

  if (state.linkDraft) state.linkDraft.toPoint = { x, y }

  if (state.dragging && state.selected) {
    state.selected.x = x - state.dragOffset.x
    state.selected.y = y - state.dragOffset.y
  }
}

/* Функция: обработчик отпускания кнопки мыши */
canvas.onmouseup = () => {
  state.dragging = false
  state.selected = null
}

/* Функция: обработчик двойного клика (удаление связи / редактирование entity) */
canvas.ondblclick = e => {
  const x = e.offsetX
  const y = e.offsetY

  // 1) Двойной клик по связи — удалить
  const link = hitLink(x, y)
  if (link) {
    state.links = state.links.filter(l => l.id !== link.id)
    if (state.selectedLinkId === link.id) state.selectedLinkId = null
    return
  }

  // 2) Двойной клик по entity — редактирование
  const node = hitNode(x, y)
  if (!node) return

  if (y <= node.y + 24) {
    const t = prompt('Заголовок сущности:', node.title)
    if (t !== null && t.trim() !== '') node.title = t.trim()
    return
  }

  const idx = Math.floor((y - (node.y + 40)) / 14)
  if (idx >= 0 && idx < node.fields.length) {
    editSingleField(node, idx)
    return
  }

  openEntityEditor(node)
}

/* Функция: обработчик правой кнопки мыши */
canvas.oncontextmenu = e => {
  e.preventDefault()
  state.linkDraft = null
}

/* Функция: обработчик клавиатуры */
addEventListener('keydown', e => {
  if (e.key === 'Escape') {
    state.linkDraft = null
    if (editorEl.style.display === 'block') closeEntityEditor()
    state.selectedLinkId = null
  }

  // Быстрый хоткей: 1/2/3 переключают инструменты как в редакторах
  if (e.key === '1') setTool('select')
  if (e.key === '2') setTool('node')
  if (e.key === '3') setTool('link')
})

/* ================= LOOP ================= */
/* Функция: основной цикл отрисовки canvas */
function loop() {
  updateRefsCache()

  ctx.clearRect(0, 0, canvas.width, canvas.height)
  drawBackgroundDots()

  state.links.forEach(drawLink)
  state.nodes.forEach(drawNode)

  // временная пунктирная линия при создании связи
  if (state.linkDraft && state.linkDraft.toPoint) {
    const p1 = intersection(state.linkDraft.from, state.linkDraft.toPoint)
    const p2 = state.linkDraft.toPoint
    ctx.strokeStyle = '#222'
    ctx.setLineDash([6, 6])
    ctx.beginPath()
    ctx.moveTo(p1.x, p1.y)
    ctx.lineTo(p2.x, p2.y)
    ctx.stroke()
    ctx.setLineDash([])
  }

  requestAnimationFrame(loop)
}
loop()
</script>

</body>
</html>
